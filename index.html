<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tekenbord</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Basisstijlen en Inter lettertype */
        :root {
            --bg-color: #f3f4f6; /* gray-100 */
            --text-color: #1f2937; /* gray-800 */
            --toolbar-bg: #ffffff; /* white */
            --toolbar-text: #4b5563; /* gray-600 */
            --canvas-bg: #ffffff; /* white - Canvas background always white */
            --canvas-border: #cccccc; /* light gray */
            --button-bg: #e5e7eb; /* gray-200 */
            --button-text: #1f2937; /* gray-800 */
            --button-hover-bg: #d1d5db; /* gray-300 */
            --active-tool-bg: #d1d5db; /* gray-300 */
            --message-bg: rgba(0, 0, 0, 0.7);
            --message-text: white;
            --sidemenu-bg: #ffffff; /* white */
            --sidemenu-border: #cccccc; /* light gray */
            --modal-bg: #ffffff; /* white */
            --modal-border: #cccccc; /* light gray */
            --modal-text: #1f2937; /* gray-800 */
        }

        body.dark-mode {
            --bg-color: #1f2937; /* gray-800 */
            --text-color: #f3f4f6; /* gray-100 */
            --toolbar-bg: #374151; /* gray-700 */
            --toolbar-text: #d1d5db; /* gray-300 */
            /* --canvas-bg is intentionally NOT changed here to keep it white */
            --canvas-border: #6b7280; /* gray-500 - Canvas border changes */
            --button-bg: #4b5563; /* gray-600 */
            --button-text: #f3f4f6; /* gray-100 */
            --button-hover-bg: #6b7280; /* gray-500 */
            --active-tool-bg: #6b7280; /* gray-500 */
            --message-bg: rgba(255, 255, 255, 0.7);
            --message-text: black;
            --sidemenu-bg: #374151; /* gray-700 */
            --sidemenu-border: #6b7280; /* gray-500 */
            --modal-bg: #374151; /* gray-700 */
            --modal-border: #6b7280; /* gray-500 */
            --modal-text: #f3f4f6; /* gray-100 */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow: hidden; /* Voorkom scrollbars van de body zelf */
        }

        h1 {
             color: var(--text-color);
        }

        .toolbar {
            background-color: var(--toolbar-bg);
            transition: background-color 0.3s ease;
            flex-shrink: 0; /* Voorkom dat toolbar krimpt */
        }

        .toolbar label, .toolbar span {
             color: var(--toolbar-text);
        }

        /* Zorg ervoor dat de canvas een duidelijke rand heeft */
        canvas {
            border: 1px solid var(--canvas-border);
            background-color: var(--canvas-bg); /* Uses the --canvas-bg variable */
            cursor: crosshair; /* Verander cursor in een kruisje boven het canvas */
            touch-action: none; /* Voorkom scrollen op touch apparaten tijdens tekenen */
            transition: background-color 0.3s ease, border-color 0.3s ease;
            display: block; /* Voorkom extra ruimte onder canvas */
            max-width: 100%; /* Zorg dat canvas niet breder wordt dan container */
        }

        /* Stijl voor de actieve tool */
        .tool-active {
            background-color: var(--active-tool-bg) !important; /* Override Tailwind */
            border: 2px solid var(--text-color); /* Extra indicatie */
        }

        /* Stijl voor knoppen */
         .toolbar button {
            background-color: var(--button-bg);
            color: var(--button-text);
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            border: 2px solid transparent; /* Ruimte voor actieve border */
            /* Added styles for smaller buttons */
            padding: 0.5rem 0.75rem; /* Smaller padding */
            display: inline-flex; /* Allow flexbox for icon centering */
            align-items: center;
            justify-content: center;
         }
         .toolbar button:hover {
             background-color: var(--button-hover-bg);
         }
         #clearBtn {
             background-color: #ef4444; /* red-500 */
             color: white;
         }
         #clearBtn:hover {
             background-color: #dc2626; /* red-600 */
         }
         body.dark-mode #clearBtn {
             background-color: #ef4444; /* red-500 */
             color: white;
         }
         body.dark-mode #clearBtn:hover {
             background-color: #dc2626; /* red-600 */
         }

         /* Stijl voor disabled knoppen */
         .toolbar button:disabled {
             opacity: 0.5;
             cursor: not-allowed;
         }

         /* Style for SVG icons within buttons */
         .toolbar button svg {
             width: 1.25rem; /* Icon size */
             height: 1.25rem; /* Icon size */
             fill: currentColor; /* Use button text color for icon */
         }

         /* Stijl voor het zijmenu */
         #sideMenu {
             position: fixed;
             top: 0;
             right: -300px; /* Start off-screen */
             width: 300px;
             height: 100%;
             background-color: var(--sidemenu-bg);
             border-left: 1px solid var(--sidemenu-border);
             box-shadow: -2px 0 5px rgba(0,0,0,0.5);
             transition: right 0.3s ease;
             z-index: 1001; /* Higher than message box */
             padding: 20px;
             display: flex;
             flex-direction: column;
         }

         #sideMenu.open {
             right: 0; /* Slide in */
         }

         #sideMenu .close-btn {
             align-self: flex-end; /* Align to the right */
             background: none;
             border: none;
             font-size: 1.5rem;
             cursor: pointer;
             color: var(--text-color); /* Use main text color */
             margin-bottom: 20px;
         }

         #sideMenu button {
             width: 100%; /* Make buttons fill menu width */
             justify-content: flex-start; /* Align text/icon to left */
             margin-bottom: 10px; /* Add some space between menu buttons */
         }

         /* Stijl voor de tekst invoer modal */
         #textInputModal {
             position: fixed;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             background-color: var(--modal-bg);
             border: 1px solid var(--modal-border);
             border-radius: 8px;
             padding: 20px;
             box-shadow: 0 4px 8px rgba(0,0,0,0.2);
             z-index: 1002; /* Higher than side menu */
             display: none; /* Hidden by default */
             flex-direction: column;
             gap: 15px;
             color: var(--modal-text);
         }

         #textInputModal.visible {
             display: flex;
         }

         #textInputModal textarea {
             width: 100%;
             padding: 10px;
             border: 1px solid var(--modal-border);
             border-radius: 4px;
             background-color: var(--bg-color); /* Use general background for input */
             color: var(--text-color); /* Use general text color for input */
             resize: vertical; /* Allow vertical resize */
         }

         #textInputModal .modal-setting {
             display: flex;
             align-items: center;
             gap: 10px;
         }

         #textInputModal select,
         #textInputModal input[type="range"] {
             padding: 8px;
             border: 1px solid var(--modal-border);
             border-radius: 4px;
             background-color: var(--bg-color); /* Use general background for select/range */
             color: var(--text-color); /* Use general text color for select/range */
         }

         #textInputModal input[type="range"] {
             flex-grow: 1; /* Allow slider to take available space */
         }


         #textInputModal .modal-buttons {
             display: flex;
             justify-content: flex-end;
             gap: 10px;
         }

         #textInputModal .modal-buttons button {
             padding: 8px 15px;
             border-radius: 4px;
             cursor: pointer;
             /* Use general button styles */
             background-color: var(--button-bg);
             color: var(--button-text);
             transition: background-color 0.15s ease;
         }
         #textInputModal .modal-buttons button:hover {
             background-color: var(--button-hover-bg);
         }


         /* Stijl voor de message box */
         #messageBox {
             position: fixed;
             top: 20px;
             left: 50%;
             transform: translateX(-50%);
             background-color: var(--message-bg);
             color: var(--message-text);
             padding: 10px 20px;
             border-radius: 8px;
             display: none; /* Standaard verborgen */
             z-index: 1000;
             transition: background-color 0.3s ease, color 0.3s ease;
         }

         /* Stijl voor de versieaanduiding */
         #versionInfo {
             position: absolute;
             top: 10px;
             right: 10px;
             font-size: 0.8rem;
             color: var(--text-color);
             opacity: 0.7; /* Maak het iets minder opvallend */
         }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body class="flex flex-col items-center justify-start min-h-screen p-4 relative">
    <div id="versionInfo">v0.8.0 beta</div>

    <h1 class="text-3xl font-bold mb-4 flex-shrink-0">Pixel & Art</h1>

    <div class="toolbar w-full max-w-4xl p-3 rounded-lg shadow-md mb-4 flex flex-wrap items-center justify-center gap-3">
        <div>
            <label for="colorPicker" class="mr-1 text-sm font-medium">Kleur:</label>
            <input type="color" id="colorPicker" value="#000000" class="h-8 w-8 rounded border border-gray-300 cursor-pointer align-middle">
        </div>

        <div>
            <label for="brushSize" class="mr-1 text-sm font-medium">Grootte:</label>
            <input type="range" id="brushSize" min="1" max="50" value="5" class="cursor-pointer align-middle w-24">
            <span id="brushSizeValue" class="ml-1 text-sm w-6 inline-block text-center">5</span>
        </div>

        <button id="drawBtn" class="px-3 py-1.5 rounded-md hover:bg-gray-300 transition duration-150 text-sm font-medium tool-active">
            Tekenen
        </button>

        <button id="eraserBtn" class="px-3 py-1.5 rounded-md hover:bg-gray-300 transition duration-150 text-sm font-medium">
            Gum
        </button>

        <button id="fillBtn" class="px-3 py-1.5 rounded-md hover:bg-gray-300 transition duration-150 text-sm font-medium">
            Vullen
        </button>

         <button id="textBtn" class="px-3 py-1.5 rounded-md hover:bg-gray-300 transition duration-150 text-sm font-medium">
             Tekst
         </button>

         <button id="lineBtn" class="px-3 py-1.5 rounded-md hover:bg-gray-300 transition duration-150 text-sm font-medium">
             Lijn
         </button>

         <input type="file" id="imageUpload" accept=".png, .jpg, .jpeg, .webp" class="hidden">
        <button id="uploadImageBtn" class="px-3 py-1.5 rounded-md hover:bg-gray-300 transition duration-150 text-sm font-medium">
            Afbeelding Uploaden
        </button>


        <button id="undoBtn" class="rounded-md hover:bg-gray-300 transition duration-150 text-sm font-medium" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm4.097 11h-8.391l2.987-2.987c.183-.183.295-.438.295-.713 0-.574-.466-1.04-1.04-1.04-.275 0-.53.112-.713.295l-4.242 4.242c-.196.196-.305.453-.305.728 0 .274.109.531.305.727l4.242 4.242c.183.183.438.295.713.295.574 0 1.04-.466 1.04-1.04 0-.275-.112-.53-.295-.713l-2.986-2.987h8.391c-.552 0-1 .448-1 1s-.448 1 1 1z"/></svg>
        </button>

        <button id="redoBtn" class="rounded-md hover:bg-gray-300 transition duration-150 text-sm font-medium" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-4.097 11h8.391l-2.987 2.987c-.183.183-.295.438-.295.713 0 .574.466 1.04 1.04 1.04.275 0 .53-.112.713-.295l4.242-4.242c.196-.196.305-.453.305.728 0-.274-.109-.531-.305-.727l-4.242-4.242c-.183-.183-.438-.295-.713-.295-.574 0-1.04.466-1.04 1.04 0 .275.112.53.295.713l2.986 2.987h-8.391c-.552 0-1 .448-1 1s-.448 1 1 1z"/></svg>
        </button>

        <button id="clearBtn" class="px-3 py-1.5 text-white rounded-md transition duration-150 text-sm font-medium">
            Wissen
        </button>

        <button id="openMenuBtn" class="px-3 py-1.5 rounded-md hover:bg-gray-300 transition duration-150 text-sm font-medium">
            Instellingen
        </button>
    </div>

    <div class="canvas-container w-full max-w-4xl flex-grow flex justify-center items-center mb-4">
         <canvas id="drawingCanvas" class="rounded-lg shadow-md"></canvas>
    </div>

    <div id="sideMenu">
        <button class="close-btn">&times;</button>
        <h2 class="text-xl font-bold mb-4">Instellingen</h2>
        <button id="darkModeToggle" class="px-3 py-1.5 rounded-md hover:bg-gray-300 transition duration-150 text-sm font-medium">
            ☀️ Licht (Klik 0/10)
        </button>
         <button id="pixelModeToggle" class="px-3 py-1.5 rounded-md hover:bg-gray-300 transition duration-150 text-sm font-medium">
             Pixel Art Mode: Uit
         </button>
         <button id="exportBtn" class="px-3 py-1.5 rounded-md hover:bg-gray-300 transition duration-150 text-sm font-medium">
            Exporteer als PNG
        </button>
    </div>

    <div id="textInputModal">
        <h3 class="text-lg font-semibold">Tekst toevoegen</h3>
        <textarea id="textInput" rows="3" placeholder="Voer hier uw tekst in..."></textarea>
        <div class="modal-setting">
            <label for="fontSelect" class="mr-2 text-sm font-medium">Lettertype:</label>
            <select id="fontSelect">
                <option value="Arial">Arial</option>
                <option value="Verdana">Verdana</option>
                <option value="Times New Roman">Times New Roman</option>
                <option value="Courier New">Courier New</option>
                <option value="Georgia">Georgia</option>
                <option value="Press Start 2P">Press Start 2P</option>
            </select>
        </div>
         <div class="modal-setting">
             <label for="textSizeSlider" class="mr-2 text-sm font-medium">Tekstgrootte:</label>
             <input type="range" id="textSizeSlider" min="10" max="100" value="20" class="cursor-pointer">
             <span id="textSizeValue" class="ml-1 text-sm w-8 inline-block text-center">20</span>
         </div>
        <div class="modal-buttons">
            <button id="cancelTextBtn">Annuleren</button>
            <button id="addTextBtn">Toevoegen</button>
        </div>
    </div>


    <div id="messageBox"></div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true }); // Prestatiehint
        const colorPicker = document.getElementById('colorPicker');
        const brushSizeSlider = document.getElementById('brushSize');
        const brushSizeValue = document.getElementById('brushSizeValue');
        const clearBtn = document.getElementById('clearBtn');
        const eraserBtn = document.getElementById('eraserBtn');
        const drawBtn = document.getElementById('drawBtn'); // New draw button
        const fillBtn = document.getElementById('fillBtn'); // New fill button
        const textBtn = document.getElementById('textBtn'); // New text button
        const lineBtn = document.getElementById('lineBtn'); // New line button
        const undoBtn = document.getElementById('undoBtn'); // New undo button
        const redoBtn = document.getElementById('redoBtn'); // New redo button
        const openMenuBtn = document.getElementById('openMenuBtn'); // New button to open menu
        const sideMenu = document.getElementById('sideMenu'); // Side menu element
        const closeMenuBtn = sideMenu.querySelector('.close-btn'); // Close button inside menu
        const darkModeToggle = document.getElementById('darkModeToggle'); // Dark mode toggle (now inside menu)
        const exportBtn = document.getElementById('exportBtn'); // New export button
        const messageBox = document.getElementById('messageBox');
        const body = document.body;
        const canvasContainer = document.querySelector('.canvas-container');

        // Text Modal Elements
        const textInputModal = document.getElementById('textInputModal');
        const textInput = document.getElementById('textInput');
        const fontSelect = document.getElementById('fontSelect');
        const textSizeSlider = document.getElementById('textSizeSlider'); // New text size slider
        const textSizeValue = document.getElementById('textSizeValue'); // New text size value span
        const addTextBtn = document.getElementById('addTextBtn');
        const cancelTextBtn = document.getElementById('cancelTextBtn');

        // New Pixel Mode Toggle Button
        const pixelModeToggle = document.getElementById('pixelModeToggle');


        // Image Upload Elements
        const imageUploadInput = document.getElementById('imageUpload');
        const uploadImageBtn = document.getElementById('uploadImageBtn');


        // Variabelen
        let isDrawing = false; // Tracks if currently drawing a line or pixels
        let lastX = 0;
        let lastY = 0;
        let lastGridX = -1; // For pixel art: track the last grid cell drawn
        let lastGridY = -1; // For pixel art: track the last grid cell drawn
        let brushColor = '#000000';
        let brushSize = 5;
        let savedColor = brushColor; // To restore color after using eraser/fill
        let currentTheme = localStorage.getItem('theme') || 'dark'; // Default to dark mode
        let currentTool = 'draw'; // 'draw', 'erase', 'fill', 'pixel', 'text', 'line', 'pixelErase', 'image'
        let activeTool = currentTool; // The tool currently active for drawing (can be 'line' temporarily)
        let toolBeforeShift = 'draw'; // Stores the tool before Shift was pressed
        let isPixelMode = false; // New variable to track pixel art mode
        let savedFont = fontSelect.value; // Save the currently selected font


        // Variables for difficult light mode toggle
        let lightModeClickCount = 0;
        const clicksToLightMode = 10;

        // History variables
        const history = [];
        let historyIndex = -1;
        const maxHistoryStates = 50; // Limit history size to prevent excessive memory usage

        // Variables for text placement
        let textPlacementX = 0;
        let textPlacementY = 0;

        // Variables for line tool
        let startLineX = 0;
        let startLineY = 0;

        // Variable to track if panning is active (for middle mouse button)
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;

        // Variables for image
        let uploadedImage = null;
        let imageX = 0;
        let imageY = 0;
        let imageWidth = 0;
        let imageHeight = 0;
        let imageRotation = 0; // Rotation in radians
        let isDraggingImage = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;


        // --- Hulpfuncties ---

        function showMessage(message) {
            messageBox.textContent = message;
            messageBox.style.display = 'block';
            clearTimeout(messageBox.timer); // Reset timer als er al een melding is
            messageBox.timer = setTimeout(() => {
                messageBox.style.display = 'none';
            }, 2000);
        }

        // Haalt de huidige achtergrondkleur op, rekening houdend met thema
        function getCurrentBgColor() {
            // Forceer browser om stijlen te herberekenen voor de zekerheid
            window.getComputedStyle(canvas).getPropertyValue('background-color');
            // Now it will always return the color defined by --canvas-bg, which is white
            return getComputedStyle(canvas).backgroundColor;
        }

        // Vult het canvas met de huidige achtergrondkleur
        function setCanvasBackground() {
            const bgColor = getCurrentBgColor();
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Converts a hex color string to an RGBA array [R, G, B, A]
        function hexToRgba(hex) {
            const bigint = parseInt(hex.replace('#', ''), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            // Assume full opacity for brush colors
            return [r, g, b, 255];
        }

        // Checks if two RGBA colors are the same, considering transparency for the target color
        function colorsMatch(color1, color2) {
             // Check if color1 is valid (prevent errors with [-1, -1, -1, -1])
             if (color1[0] === -1) return false;
             // Check if color2 is valid
             if (color2[0] === -1) return false;

             // If the target color is fully transparent, match any fully transparent pixel
             if (color1[3] === 0) {
                 return color2[3] === 0;
             }

             // Otherwise, perform a full RGBA match
             return color1[0] === color2[0] &&
                    color1[1] === color2[1] &&
                    color1[2] === color2[2] &&
                    color1[3] === color2[3];
        }


        // Flood fill algorithm
        function floodFill(startX, startY, targetColor, replacementColor) {
            // Get image data
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const width = canvas.width;
            const height = canvas.height;

            // Check if target and replacement colors are the same
            if (colorsMatch(targetColor, replacementColor)) {
                return; // No need to fill
            }

            // Queue for pixels to visit
            const queue = [[startX, startY]];

            // Helper function to get pixel color at (x, y)
            function getPixelColor(x, y) {
                const index = (y * width + x) * 4;
                // Ensure index is within bounds
                if (index < 0 || index >= pixels.length) {
                    return [-1, -1, -1, -1]; // Indicate invalid pixel
                }
                return [pixels[index], pixels[index + 1], pixels[index + 2], pixels[index + 3]];
            }

            // Helper function to set pixel color at (x, y)
            function setPixelColor(x, y, color) {
                const index = (y * width + x) * 4;
                 // Ensure index is within bounds
                 if (index < 0 || index >= pixels.length) {
                     return;
                 }
                pixels[index] = color[0];
                pixels[index + 1] = color[1];
                pixels[index + 2] = color[2];
                pixels[index + 3] = color[3];
            }

            // Process the queue
            while (queue.length > 0) {
                const [x, y] = queue.shift(); // Get the next pixel

                // Check bounds
                if (x < 0 || x >= width || y < 0 || y >= height) {
                    continue;
                }

                // Get current pixel color
                const currentColor = getPixelColor(x, y);

                // If the current color matches the target color and is valid
                if (colorsMatch(currentColor, targetColor)) {
                    // Set the pixel to the replacement color
                    setPixelColor(x, y, replacementColor);

                    // Add neighbors to the queue
                    queue.push([x + 1, y]);
                    queue.push([x - 1, y]);
                    queue.push([x, y + 1]);
                    queue.push([x, y - 1]);
                }
            }

            // Put the modified image data back
            ctx.putImageData(imageData, 0, 0);
        }


        // Updates the active tool button styles and text based on currentTool and isPixelMode
        function updateToolButtonStyles() {
            // Remove active class from all tool buttons
            drawBtn.classList.remove('tool-active');
            eraserBtn.classList.remove('tool-active');
            fillBtn.classList.remove('tool-active');
            textBtn.classList.remove('tool-active');
            lineBtn.classList.remove('tool-active');
            uploadImageBtn.classList.remove('tool-active'); // Remove active from upload image button

            // Update button text based on pixel mode
            if (isPixelMode) {
                drawBtn.textContent = 'Pixel Pen';
                eraserBtn.textContent = 'Pixel Gum';
                lineBtn.textContent = 'Pixel Lijn';
            } else {
                drawBtn.textContent = 'Tekenen';
                eraserBtn.textContent = 'Gum';
                lineBtn.textContent = 'Lijn';
            }
             // Update pixel mode toggle button text
             pixelModeToggle.textContent = `Pixel Art Mode: ${isPixelMode ? 'Aan' : 'Uit'}`;


            // Add active class to the current tool button
            if (currentTool === 'draw') {
                drawBtn.classList.add('tool-active');
            } else if (currentTool === 'erase') {
                eraserBtn.classList.add('tool-active');
            } else if (currentTool === 'fill') {
                fillBtn.classList.add('tool-active');
            } else if (currentTool === 'text') {
                textBtn.classList.add('tool-active');
            } else if (currentTool === 'line') {
                lineBtn.classList.add('tool-active');
            } else if (currentTool === 'image') { // Add case for image tool
                 uploadImageBtn.classList.add('tool-active'); // Highlight upload button when image tool is active
            }

            // Update cursor based on activeTool and isPixelMode
            if (activeTool === 'fill') {
                canvas.style.cursor = 'crosshair'; // Or 'pointer', depending on preference
            } else if (activeTool === 'image' && uploadedImage) {
                 canvas.style.cursor = 'move'; // Indicate image is movable
            }
            else { // draw, erase, pixel, text, line, pixelErase
                 canvas.style.cursor = 'crosshair';
            }
        }

        // Saves the current canvas state to the history stack
        function saveState() {
            console.log("Saving state...");
            if (canvas.width > 0 && canvas.height > 0) {
                 // If we are not at the end of the history (meaning we've undone some actions),
                 // discard the future states before adding a new one.
                 if (historyIndex < history.length - 1) {
                     history.splice(historyIndex + 1);
                 }

                 // Get the current image data
                 const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                 // Add the state to the history
                 // For image tool, we need to save the image object and its properties
                 if (currentTool === 'image' && uploadedImage) {
                     // Create a temporary canvas to get the image data *without* the current image
                     const tempCanvas = document.createElement('canvas');
                     tempCanvas.width = canvas.width;
                     tempCanvas.height = canvas.height;
                     const tempCtx = tempCanvas.getContext('2d');

                     // Draw the base drawing onto the temporary canvas
                     if (historyIndex >= 0 && history[historyIndex].type === 'image') {
                          // If the previous state was also an image, use its base imageData
                          tempCtx.putImageData(history[historyIndex].imageData, 0, 0);
                     } else if (historyIndex >= 0) {
                          // If the previous state was a drawing, use its imageData
                          tempCtx.putImageData(history[historyIndex].imageData, 0, 0);
                     } else {
                          // If no previous state, fill with background
                          tempCtx.fillStyle = getCurrentBgColor();
                          tempCtx.fillRect(0, 0, canvas.width, canvas.height);
                     }


                     history.push({
                          type: 'image',
                          // Save the base drawing data *before* drawing the image on top
                          imageData: tempCtx.getImageData(0, 0, canvas.width, canvas.height),
                          image: uploadedImage,
                          x: imageX,
                          y: imageY,
                          width: imageWidth,
                          height: imageHeight,
                          rotation: imageRotation
                     });
                     console.log("State saved: Image state");
                 } else {
                     history.push({
                          type: 'drawing', // Indicate this is a regular drawing state
                          imageData: imageData
                     });
                     console.log("State saved: Drawing state");
                 }


                 // Limit history size
                 if (history.length > maxHistoryStates) {
                     history.shift(); // Remove the oldest state
                 }

                 // Update the history index to point to the new last state
                 historyIndex = history.length - 1;

                 // Update button states
                 updateHistoryButtons();
                 console.log("History index:", historyIndex);
            } else {
                console.log("Canvas dimensions are zero, cannot save state.");
            }
        }

        // Restores a canvas state from the history stack
        function restoreState(index) {
            console.log("Restoring state to index:", index);
            if (index >= 0 && index < history.length) {
                const state = history[index];

                // Always clear canvas and set background first
                setCanvasBackground();
                console.log("Canvas cleared and background set.");

                // Restore the base drawing if present
                if (state.imageData) {
                     ctx.putImageData(state.imageData, 0, 0);
                     console.log("Restored base drawing.");
                } else {
                    console.log("No base drawing data in state.");
                }


                // If the state includes an image, set the image variables and draw it
                if (state.type === 'image' && state.image) {
                    uploadedImage = state.image;
                    imageX = state.x;
                    imageY = state.y;
                    imageWidth = state.width;
                    imageHeight = state.height;
                    imageRotation = state.rotation;
                    console.log("Restored image state:", {x: imageX, y: imageY, width: imageWidth, height: imageHeight, rotation: imageRotation});
                    // Redraw the image on top of the restored base drawing
                    drawImageOnCanvas();
                } else {
                    // If the state is not an image state, ensure uploadedImage is null
                    uploadedImage = null;
                    console.log("Restored non-image state. uploadedImage set to null.");
                }


                historyIndex = index; // Update the history index
                updateHistoryButtons(); // Update button states
                console.log("History index after restore:", historyIndex);
            } else {
                console.log("Invalid history index for restore:", index);
            }
        }

        // Updates the disabled state of the undo and redo buttons
        function updateHistoryButtons() {
            undoBtn.disabled = historyIndex <= 0; // Disable undo if at the first state or no states
            redoBtn.disabled = historyIndex >= history.length - 1; // Disable redo if at the last state
            console.log(`History buttons updated: Undo disabled=${undoBtn.disabled}, Redo disabled=${redoBtn.disabled}`);
        }

        // Gets the mouse position relative to the canvas
        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            // Handle both mouse and touch events
            const clientX = event.clientX || event.touches[0].clientX;
            const clientY = event.clientY || event.touches[0].clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        // Draws a single pixel in pixel art mode
        function drawPixel(x, y, color, size) {
            const pixelSize = size; // In pixel mode, brushSize determines pixel size
            const gridX = Math.floor(x / pixelSize) * pixelSize;
            const gridY = Math.floor(y / pixelSize) * pixelSize;

            // Only draw if the grid cell is different from the last one drawn
            if (gridX !== lastGridX || gridY !== lastGridY) {
                ctx.fillStyle = color;
                ctx.fillRect(gridX, gridY, pixelSize, pixelSize);
                lastGridX = gridX;
                lastGridY = gridY;
            }
        }

         // Erases a single pixel in pixel art mode
         function erasePixel(x, y, size) {
             const pixelSize = size; // In pixel mode, brushSize determines pixel size
             const gridX = Math.floor(x / pixelSize) * pixelSize;
             const gridY = Math.floor(y / pixelSize) * pixelSize;

             // Only erase if the grid cell is different from the last one erased
             if (gridX !== lastGridX || gridY !== lastGridY) {
                 ctx.clearRect(gridX, gridY, pixelSize, pixelSize);
                 lastGridX = gridX;
                 lastGridY = gridY;
             }
         }


        // Starts the drawing process
        function startDrawing(event) {
            if (activeTool === 'image') {
                // Handle image dragging if the click is on the image
                const pos = getMousePos(event);
                 if (uploadedImage && pos.x >= imageX && pos.x <= imageX + imageWidth && pos.y >= imageY && pos.y <= imageY + imageHeight) {
                     isDraggingImage = true;
                     dragOffsetX = pos.x - imageX;
                     dragOffsetY = pos.y - imageY;
                     canvas.style.cursor = 'grabbing'; // Indicate dragging
                 }
                return; // Don't start drawing lines/pixels if in image tool
            }

            if (activeTool === 'line') {
                // For line tool, just record the start point on mousedown
                const pos = getMousePos(event);
                startLineX = pos.x;
                startLineY = pos.y;
                isDrawing = true; // Indicate that a line is being started
                saveState(); // Save state before starting the line draw
                return; // Don't proceed with regular drawing logic
            }

            isDrawing = true;
            const pos = getMousePos(event);
            lastX = pos.x;
            lastY = pos.y;

            // For pixel mode, draw the first pixel immediately
            if (isPixelMode) {
                if (currentTool === 'draw') {
                    drawPixel(lastX, lastY, brushColor, brushSize);
                } else if (currentTool === 'erase') {
                    erasePixel(lastX, lastY, brushSize);
                }
                 lastGridX = Math.floor(lastX / brushSize) * brushSize; // Initialize last grid pos
                 lastGridY = Math.floor(lastY / brushSize) * brushSize; // Initialize last grid pos
            } else {
                 // Start a new path for continuous drawing
                 ctx.beginPath();
                 ctx.moveTo(lastX, lastY);
            }
            saveState(); // Save state at the start of a drawing action (except for line, saved above)
        }

        // Performs the drawing action
        function draw(event) {
            // Allow image dragging even if not 'isDrawing'
            if (activeTool === 'image' && isDraggingImage) {
                 const pos = getMousePos(event);
                 const currentX = pos.x;
                 const currentY = pos.y;
                 // Update image position while dragging
                 imageX = currentX - dragOffsetX;
                 imageY = currentY - dragOffsetY;
                 // Redraw the canvas with the updated image position
                 redrawCanvas();
                 return; // Don't proceed with other drawing logic
            }

            // Rest of the drawing logic only if isDrawing is true
            if (!isDrawing) return; // Only draw if isDrawing is true

            const pos = getMousePos(event);
            const currentX = pos.x;
            const currentY = pos.y;

            if (activeTool === 'line') {
                redrawCanvas(); // Clear canvas and redraw previous state

                if (isPixelMode) {
                    // Pixel line drawing using a simplified Bresenham-like approach
                    const x0 = Math.floor(startLineX / brushSize) * brushSize;
                    const y0 = Math.floor(startLineY / brushSize) * brushSize;
                    const x1 = Math.floor(currentX / brushSize) * brushSize;
                    const y1 = Math.floor(currentY / brushSize) * brushSize;

                    const dx = Math.abs(x1 - x0);
                    const dy = Math.abs(y1 - y0);
                    const sx = (x0 < x1) ? brushSize : -brushSize;
                    const sy = (y0 < y1) ? brushSize : -brushSize;
                    let err = dx - dy;

                    let x = x0;
                    let y = y0;

                    while (true) {
                        drawPixel(x, y, brushColor, brushSize); // Draw the pixel

                        if ((x === x1) && (y === y1)) break;
                        const e2 = 2 * err;
                        if (e2 > -dy) { err -= dy; x += sx; }
                        if (e2 < dx) { err += dx; y += sy; }
                    }

                } else {
                    // Regular smooth line drawing
                    ctx.lineWidth = brushSize;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.strokeStyle = brushColor;

                    ctx.beginPath();
                    ctx.moveTo(startLineX, startLineY);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    ctx.closePath();
                }
                return; // Stop here for line tool
            }

            if (isPixelMode) {
                // In pixel mode, draw pixels based on grid
                if (currentTool === 'draw') {
                    drawPixel(currentX, currentY, brushColor, brushSize);
                } else if (currentTool === 'erase') {
                    erasePixel(currentX, currentY, brushSize);
                }
            } else {
                // Regular drawing mode
                ctx.lineWidth = brushSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                if (currentTool === 'draw') {
                    ctx.strokeStyle = brushColor;
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                } else if (currentTool === 'erase') {
                    // Use 'destination-out' composite operation for erasing
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.strokeStyle = 'rgba(0,0,0,1)'; // Color doesn't matter for erase, but needs to be set
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    ctx.globalCompositeOperation = 'source-over'; // Reset to default
                }
                lastX = currentX;
                lastY = currentY;
            }
        }

        // Stops the drawing process
        function stopDrawing(event) {
             // Stop image dragging even if not 'isDrawing'
             if (activeTool === 'image' && isDraggingImage) {
                 isDraggingImage = false;
                 canvas.style.cursor = activeTool === 'image' && uploadedImage ? 'move' : 'crosshair'; // Restore cursor
                 saveState(); // Save state after image is dropped
                 return; // Don't proceed with other stop logic
             }

            // Rest of the stop drawing logic only if isDrawing is true
            if (!isDrawing) return; // Only stop if isDrawing is true

            isDrawing = false;
            ctx.closePath(); // Close the path for regular drawing

            // For line tool, the final line is drawn in the last mousemove before mouseup
            // We just need to save the state here if it was a line drawing action
             if (activeTool === 'line') {
                 // The final line is drawn in the last mousemove before mouseup
                 // We just need to save the state here.
                 // saveState(); // State is already saved at the start of line draw, no need to save again here
             } else {
                 // For other tools, save state after the drawing action is complete
                 // (already saved at the start, but saving again ensures the final state is captured)
                 // saveState(); // This might save too many states, let's rely on the startDrawing save
             }


            // Reset pixel grid tracking
            lastGridX = -1;
            lastGridY = -1;
        }

        // Handles clicks on the canvas (for fill and text tools)
        function handleCanvasClick(event) {
            const pos = getMousePos(event);
            const clickX = Math.floor(pos.x);
            const clickY = Math.floor(pos.y);

            if (currentTool === 'fill') {
                // Get the color of the clicked pixel
                const pixelColor = ctx.getImageData(clickX, clickY, 1, 1).data;
                const targetColor = [pixelColor[0], pixelColor[1], pixelColor[2], pixelColor[3]];

                // Get the replacement color (current brush color)
                const replacementColor = hexToRgba(brushColor);

                // Perform flood fill
                saveState(); // Save state before filling
                floodFill(clickX, clickY, targetColor, replacementColor);
                saveState(); // Save state after filling
            } else if (currentTool === 'text') {
                // Store the click position for text placement
                textPlacementX = clickX;
                textPlacementY = clickY;
                // Show the text input modal
                textInputModal.classList.add('visible');
                 // Set the default font in the modal to the saved font
                 fontSelect.value = savedFont;
                 // Update the text size value span
                 textSizeValue.textContent = textSizeSlider.value;
            } else if (currentTool === 'image' && uploadedImage) {
                 // If in image tool and an image is loaded, check if the click is on the image
                 if (clickX >= imageX && clickX <= imageX + imageWidth && clickY >= imageY && clickY <= imageY + imageHeight) {
                     // If clicked on the image, do nothing or perhaps show options (not implemented)
                     console.log("Clicked on the image.");
                 } else {
                     // If clicked outside the image, maybe finalize the image position?
                     // For now, we just don't do anything on click outside the image.
                     console.log("Clicked outside the image.");
                 }
            }
        }

        // Redraws the canvas, including the base drawing and the current image if any
        function redrawCanvas() {
             // Always clear the canvas and set the background
             setCanvasBackground();

             // Restore the base drawing from the current history state if available
             if (historyIndex >= 0 && history[historyIndex].imageData) {
                 ctx.putImageData(history[historyIndex].imageData, 0, 0);
             } else if (historyIndex === -1 && history.length > 0 && history[0].imageData) {
                 // Handle case where historyIndex is -1 but there's an initial state
                  ctx.putImageData(history[0].imageData, 0, 0);
             }


             // Draw the uploaded image if it exists and is the current state
             if (uploadedImage && historyIndex >= 0 && history[historyIndex].type === 'image') {
                 drawImageOnCanvas();
             }
        }

        // Draws the uploaded image onto the canvas
        function drawImageOnCanvas() {
             if (uploadedImage) {
                 ctx.save(); // Save the current canvas state
                 ctx.translate(imageX + imageWidth / 2, imageY + imageHeight / 2); // Move origin to center of image
                 ctx.rotate(imageRotation); // Apply rotation
                 ctx.drawImage(uploadedImage, -imageWidth / 2, -imageHeight / 2, imageWidth, imageHeight); // Draw image centered
                 ctx.restore(); // Restore canvas state
             }
        }


        // --- Event Handlers ---

        // Update brush size value display
        brushSizeSlider.addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            brushSizeValue.textContent = brushSize;
        });

        // Update brush color
        colorPicker.addEventListener('input', (e) => {
            brushColor = e.target.value;
            savedColor = brushColor; // Also update saved color
        });

        // Select Draw tool
        drawBtn.addEventListener('click', () => {
            currentTool = 'draw';
            activeTool = 'draw'; // Ensure activeTool is also draw
            brushColor = savedColor; // Restore drawing color
            updateToolButtonStyles();
        });

        // Select Eraser tool
        eraserBtn.addEventListener('click', () => {
            currentTool = 'erase';
            activeTool = 'erase'; // Ensure activeTool is also erase
            updateToolButtonStyles();
        });

        // Select Fill tool
        fillBtn.addEventListener('click', () => {
            currentTool = 'fill';
            activeTool = 'fill'; // Ensure activeTool is also fill
            brushColor = savedColor; // Restore drawing color
            updateToolButtonStyles();
        });

        // Select Text tool
        textBtn.addEventListener('click', () => {
            currentTool = 'text';
            activeTool = 'text'; // Ensure activeTool is also text
            updateToolButtonStyles();
        });

        // Select Line tool
        lineBtn.addEventListener('click', () => {
            currentTool = 'line';
            activeTool = 'line'; // Ensure activeTool is also line
            brushColor = savedColor; // Restore drawing color
            updateToolButtonStyles();
        });

        // Trigger image upload input click
        uploadImageBtn.addEventListener('click', () => {
            imageUploadInput.click();
        });

        // Handle image file selection
        imageUploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        uploadedImage = img;
                        // Set initial image position and size (centered and scaled)
                        const maxCanvasDim = Math.min(canvas.width, canvas.height);
                        const maxImageDim = Math.max(img.width, img.height);
                        let scale = 1;
                        if (maxImageDim > maxCanvasDim * 0.8) { // Scale down if image is too large
                             scale = (maxCanvasDim * 0.8) / maxImageDim;
                        }
                        imageWidth = img.width * scale;
                        imageHeight = img.height * scale;
                        imageX = (canvas.width - imageWidth) / 2;
                        imageY = (canvas.height - imageHeight) / 2;
                        imageRotation = 0; // Reset rotation on new image

                        currentTool = 'image'; // Switch to image tool
                        activeTool = 'image'; // Set active tool to image
                        updateToolButtonStyles();
                        saveState(); // Save state with the new image
                        redrawCanvas(); // Draw the image on the canvas
                        showMessage("Afbeelding geladen. Klik en sleep om te verplaatsen.");
                    };
                    img.onerror = () => {
                         showMessage("Fout bij het laden van de afbeelding.");
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });


        // Undo button
        undoBtn.addEventListener('click', () => {
            if (historyIndex > 0) {
                restoreState(historyIndex - 1);
            }
        });

        // Redo button
        redoBtn.addEventListener('click', () => {
            if (historyIndex < history.length - 1) {
                restoreState(historyIndex + 1);
            }
        });

        // Clear canvas button
        clearBtn.addEventListener('click', () => {
            saveState(); // Save the current state before clearing
            setCanvasBackground(); // Clear and set background
            uploadedImage = null; // Also clear the uploaded image
            imageX = 0;
            imageY = 0;
            imageWidth = 0;
            imageHeight = 0;
            imageRotation = 0;
            saveState(); // Save the cleared state
            showMessage("Canvas gewist.");
        });

        // Open side menu
        openMenuBtn.addEventListener('click', () => {
            sideMenu.classList.add('open');
        });

        // Close side menu
        closeMenuBtn.addEventListener('click', () => {
            sideMenu.classList.remove('open');
        });

        // Dark mode toggle (inside side menu)
        darkModeToggle.addEventListener('click', () => {
            if (currentTheme === 'light') {
                lightModeClickCount++;
                if (lightModeClickCount >= clicksToLightMode) {
                    body.classList.remove('dark-mode');
                    currentTheme = 'light';
                    localStorage.setItem('theme', 'light');
                    darkModeToggle.textContent = `☀️ Licht (Klik ${lightModeClickCount}/${clicksToLightMode})`;
                    showMessage("Lichte modus geactiveerd!");
                } else {
                    darkModeToggle.textContent = `☀️ Licht (Klik ${lightModeClickCount}/${clicksToLightMode})`;
                    showMessage(`Nog ${clicksToLightMode - lightModeClickCount} klik(s) voor lichte modus.`);
                }
            } else { // Currently dark mode
                body.classList.add('dark-mode');
                currentTheme = 'dark';
                localStorage.setItem('theme', 'dark');
                darkModeToggle.textContent = `🌙 Donker`;
                lightModeClickCount = 0; // Reset click count
                showMessage("Donkere modus geactiveerd.");
            }
            // After changing theme, redraw to update canvas border color if needed
            redrawCanvas();
        });

         // Pixel Mode Toggle (inside side menu)
         pixelModeToggle.addEventListener('click', () => {
             isPixelMode = !isPixelMode; // Toggle pixel mode
             updateToolButtonStyles(); // Update button text and active state
             showMessage(`Pixel Art Mode: ${isPixelMode ? 'Aan' : 'Uit'}`);
             // Note: Brush size slider still controls the pixel size in pixel mode.
         });


        // Export canvas as PNG (inside side menu)
        exportBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'tekening.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
            showMessage("Afbeelding geëxporteerd als PNG.");
        });

        // Text input modal: Add Text button
        addTextBtn.addEventListener('click', () => {
            const text = textInput.value.trim();
            const font = fontSelect.value;
            const size = parseInt(textSizeSlider.value);
            const color = brushColor; // Use current brush color for text

            if (text) {
                saveState(); // Save state before adding text

                ctx.fillStyle = color;
                ctx.font = `${size}px "${font}"`;
                ctx.fillText(text, textPlacementX, textPlacementY + size * 0.8); // Adjust Y for baseline

                saveState(); // Save state after adding text
                textInput.value = ''; // Clear text input
                textInputModal.classList.remove('visible');
                showMessage("Tekst toegevoegd.");
            } else {
                showMessage("Voer tekst in om toe te voegen.");
            }
        });

        // Text input modal: Cancel button
        cancelTextBtn.addEventListener('click', () => {
            textInput.value = ''; // Clear text input
            textInputModal.classList.remove('visible');
            showMessage("Tekst toevoegen geannuleerd.");
        });

         // Text size slider update value display
         textSizeSlider.addEventListener('input', (e) => {
             textSizeValue.textContent = e.target.value;
         });

         // Save selected font when changed in modal
         fontSelect.addEventListener('change', (e) => {
             savedFont = e.target.value;
         });


        // --- Canvas Event Listeners ---

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
             // Middle mouse button for panning
             if (e.button === 1) { // Middle mouse button
                 isPanning = true;
                 const pos = getMousePos(e);
                 panStartX = pos.x;
                 panStartY = pos.y;
                 canvas.style.cursor = 'grabbing';
                 return; // Don't start drawing if panning
             }
             // Only start drawing with left mouse button (button 0)
             if (e.button === 0) {
                startDrawing(e);
             }
        });

        canvas.addEventListener('mousemove', (e) => {
             if (isPanning) {
                 // Panning logic (not fully implemented, would require translating the canvas context)
                 // For now, we just change cursor
                 return;
             }
            draw(e);
        });

        canvas.addEventListener('mouseup', (e) => {
             if (isPanning) {
                 isPanning = false;
                 canvas.style.cursor = activeTool === 'image' && uploadedImage ? 'move' : 'crosshair'; // Restore cursor
                 return; // Don't stop drawing if panning stopped
             }
             // Only stop drawing with left mouse button (button 0)
             if (e.button === 0) {
                stopDrawing(e);
             }
        });

        // Prevent default behavior for middle mouse button (e.g., scrolling)
         canvas.addEventListener('contextmenu', (e) => {
             if (isPanning) {
                 e.preventDefault();
             }
         });


        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling and other default touch behaviors
            if (e.touches.length === 1) { // Only handle single touch for drawing/tools
                 // Simulate mousedown for touch
                const touch = e.touches[0];
                const simulatedEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    button: 0, // Simulate left click
                    bubbles: true,
                    cancelable: true
                });
                canvas.dispatchEvent(simulatedEvent);
            }
        }, { passive: false }); // Use passive: false to allow preventDefault

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling
             if (e.touches.length === 1) { // Only handle single touch for drawing/tools
                 // Simulate mousemove for touch
                const touch = e.touches[0];
                const simulatedEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    bubbles: true,
                    cancelable: true
                });
                canvas.dispatchEvent(simulatedEvent);
            }
        }, { passive: false }); // Use passive: false to allow preventDefault

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault(); // Prevent default touch behaviors
             // Simulate mouseup for touch (only if a touch started the drawing or dragging)
             if (isDrawing || isDraggingImage) { // Check if a drawing or dragging action was active
                 const simulatedEvent = new MouseEvent('mouseup', {
                     clientX: e.changedTouches[0].clientX, // Use changedTouches for touchend
                     clientY: e.changedTouches[0].clientY, // Use changedTouches for touchend
                     button: 0, // Simulate left click
                     bubbles: true,
                     cancelable: true
                 });
                 canvas.dispatchEvent(simulatedEvent);
             }
        }, { passive: false }); // Use passive: false to allow preventDefault


        // Click event for fill and text tools (only trigger on click, not drag)
        canvas.addEventListener('click', (e) => {
             // Only trigger click logic if not currently drawing or dragging an image
             if (!isDrawing && !isDraggingImage) {
                 handleCanvasClick(e);
             }
        });


        // Handle Shift key for temporary tool switching (e.g., draw to erase)
        document.addEventListener('keydown', (e) => {
             if (e.key === 'Shift' && !e.repeat) { // Check for Shift key down, ignore key repeat
                 toolBeforeShift = currentTool; // Store the current tool
                 if (currentTool === 'draw' || currentTool === 'pixel') {
                     activeTool = isPixelMode ? 'pixelErase' : 'erase'; // Switch to erase (pixel or regular)
                 } else if (currentTool === 'erase' || currentTool === 'pixelErase') {
                     activeTool = isPixelMode ? 'pixel' : 'draw'; // Switch to draw (pixel or regular)
                 }
                 // Add other tool switches if needed (e.g., Shift+Line -> Eraser)
                 updateToolButtonStyles(); // Update cursor and button styles
             }
        });

        document.addEventListener('keyup', (e) => {
             if (e.key === 'Shift') { // Check for Shift key up
                 activeTool = currentTool; // Revert to the original tool
                 updateToolButtonStyles(); // Update cursor and button styles
             }
        });


        // --- Canvas Resizing ---

        // Function to resize the canvas based on container size
        function resizeCanvas() {
            const containerWidth = canvasContainer.clientWidth;
            const containerHeight = canvasContainer.clientHeight;

            // Set canvas dimensions
            canvas.width = containerWidth;
            canvas.height = containerHeight;

            console.log(`Canvas resized to: ${canvas.width}x${canvas.height}`);

            // Redraw the canvas content after resizing
            redrawCanvas();

             // Save the new canvas size as the initial state if history is empty
             if (history.length === 0) {
                 setCanvasBackground();
                 saveState();
             } else {
                 // If history exists, save the state after resizing and redrawing
                 // This ensures the current drawing is preserved at the new size
                 saveState();
             }
        }

        // Resize the canvas when the window is resized
        window.addEventListener('resize', resizeCanvas);


        // --- Initial Setup ---

        // Set initial canvas size and background
        resizeCanvas();

        // Apply saved theme on load
        if (currentTheme === 'dark') {
            body.classList.add('dark-mode');
            darkModeToggle.textContent = `🌙 Donker`;
        } else {
             body.classList.remove('dark-mode');
             darkModeToggle.textContent = `☀️ Licht (Klik ${lightModeClickCount}/${clicksToLightMode})`;
        }


        // Initial save of the empty canvas state
        if (history.length === 0) {
             setCanvasBackground(); // Ensure canvas is white initially
             saveState();
        }

        // Update initial button states
        updateHistoryButtons();
        updateToolButtonStyles(); // Set initial tool button style and cursor


    </script>
</body>
</html>
